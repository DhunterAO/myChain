# myChain

## 一、用户层面  
依然采用比特币设计的公私钥对，为了实现简便先采用ecdsa库中默认椭圆曲线。  
一钱包对多账户，一账户对多地址。先用明文存储，后面加入对称加密机制保护账户。  

## 二、交易vs授权  
每个交易有多个输入输出，存在找零，并对每个输入有解锁脚本进行验证，每个输出有锁定脚本。还会检查输入是否存在“双花”，是否到锁定时间，输入和是否大于等于输出和。  
每个授权有多个输入输出，不存在找零，对每个输入有解锁脚本进行验证，每个输出有锁定脚本。不检查是否存在“双花”，会检查是否在合法时间内，输入授权和（与）是否包含输出授权a&b=a。由于不存在双花，所以也不用实现UTXO和UTXOpool。  
但是为了防止已上链授权重复广播，需要增加hash_pool  

## 三、脚本层面  
简化使用比特币脚本语言，先解决单地址签名验证脚本，再加入多地址多签名，后续考虑扩展到图灵完备。

## 四、区块层面   
每个比特币区块分头部和交易部分：   
头部有多个交易组成Merkle树的hash根，生成时间戳，还有上一区块hash值，本区块hash值，以及变动的nonce。  
交易部分有多个交易组成Merkle树。不设置隔离见证  
授权区块也分头部和交易，没有coinbase交易。由于授权比交易占用更多空间，每个区块大小上限设置为8M。  

## 五、区块链层面  
多个区块组成区块链，每个区块存有之前区块的hash值。与比特币一致。  

## 六、网络层面  
简单的p2p网络，暂时不考虑通信认证、心跳包等。都从内嵌地址中请求连接节点。每个节点最多保存20个邻居节点。  

## 七、共识算法  
Pow共识算法，难度控制在平均1分钟出一块，由于不存在双花问题，所以没有分叉攻击的意义，最多受到拒绝服务攻击。

## 八、增加数据库与认证部分  
用户对服务器上传文件自动获得服务器签发的对应文件授权，用户发送对\[自己公钥、当前时间戳、请求数据和操作、获得授权的区块编号、授权编号、授权内编号]的hash值签名，服务器用收到的公钥对该签名进行验证。验证成功后去区块链对应位置找到授权进行认证请求数据以及操作是否超出授权范围。
